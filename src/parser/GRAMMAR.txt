# Bigint Calculator Grammar Specification.
#
# Specification Syntax.
#
# A "#" symbol indicates a line comment.
# Rules can be concatenated with zero or more spaces unless a space is
# explicitly included or excluded in a rule.
#
# rule_name = rule rule ... : Syntax of a rule definitions.
# ...+      : one or more occurrences of the preceding sequence.
# ...*      : zero or more occurrences of the preceding sequence.
# ...?      : indicates that the preceding sequence is optional.
# ... | ... : indicates an option of two rules. Can also be chained together to
#             indicate more options.
# (...)     : rules enclosed in parenthesis are grouped together and operators
#             are applied to the whole group.
# "..."     : literal character sequence that can be found in the program,
#             such as keywords.
# '...'     : same as above.
# [...]     : a set of literal characters to choose from.
# [...-...] : indicates a range of characters, for example [A-Z] indicates
#             capital English alphabet characters.
# !...      : negates the sequence that follows, i.e. the following sequence
#             should not match for the rule.
# .         : a single period means any character can be placed in that position.

# Expressions have their value printed to stdout if free standing.
program     = (statement | expression terminator | "\n")*

# Statements do not return any value.
statement   = block_stmt | simple_stmt terminator
block_stmt  = block
            | "def" identifier "(" identifier ("," "\n"? identifier)* ")" "\n"? block
            | if_stmt
            | "else" ( "\n"? block | if_stmt)
            | "while" "(" test ")" "\n"? block
simple_stmt = identifier "=" expression
            | "print" !space "(" expr_list ")"
            | "break"
            | "exit"
            | "return" expression?
terminator  = "\n" | ";"
block       = "{" "\n"* statement* "\n"* "}"
identifier  = [a-zA-Z_] !space [a-zA-Z0-9_]*
if_stmt     = "if" "("  test ")" "\n"? block

# Expressions return values.
expression  = "(" expression ")"
            | identifier !space "(" expr_list ")" # Function call
            | unary_op !space expression
            | (identifier ("[" !array expression "]")? | number) (binary_op !array expression)*
            | test
            | string
            | array
            | "number" !space "(" string "," ("2"-"36") ")"
space       = " " | "\t"
expr_list   = !test expression ("," "\n"? !test expression)*
test        = expression (condition_op expression)?
unary_op    = ("++" | "--") space | ([+-] !space)+
binary_op   = space [+-] space | [*/%^]
number      = [0-9] !space [a-zA-Z0-9_]*
string      = '"' (. !'"')* '"'
array       = "[" expr_list "]"
condition_op= [><] | "==" | "<=" | ">="

# Comments can be placed anywhere in the program. They will make the parser
# ignore any commented out sequence.
comment     = line_comment | block_comment

# Line comments comment out everything in between the opening character and the
# next newline character.
line_comment    = "#" (. !"\n")* "\n"

# Block comments comment out everything in between the opening and closing characters,
# including newlines.
block_comment   = "/*" (. !"*/")* "*/"
